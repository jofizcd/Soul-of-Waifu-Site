const translations = {
    ru: {
        features: "Возможности",
        screenshots: "Скриншоты",
        history: "История",
        download: "Скачать",
        heroTitle: "Вдохните душу в ваших любимых персонажей",
        heroDescription: "Soul of Waifu - это десктопное приложение с открытым исходным кодом, где вы можете оживить своих персонажей и вести общение с ИИ-моделями - даже локальными. Никаких сложных настроек, только мгновенное погружение в мир ролевых игр с нейросетью!",
        downloadBtn: "Скачать для Windows",
        learnMoreBtn: "Документация",
        scrollText: "Прокрутите вниз",
        featuresTitle: "Основные возможности",
        featureTitle1: "Простота и удобство",
        featureDesc1: "Даже если вы впервые сталкиваетесь с ИИ - не волнуйтесь. Интутивно понятный интерфейс делает взаимодействие с приложением легким, понятным и приятным с первого запуска.",
        featureTitle2: "Языковые модели",
        featureDesc2: "Вы можете использовать API от ведущих платформ, но программа также позволяет запускать локальные языковые модели прямо внутри неё.",
        featureTitle3: "Общение с персонажами",
        featureDesc3: "Общайтесь с персонажами с помощью многофункционального чата - кастомизируйте, управляйте сообщениями, импортируйте чаты и звоните персонажам.",
        featureTitle4: "Голос и анимация",
        featureDesc4: "Персонажи могут говорить через различные TTS-системы и реагировать с помощью поз и анимаций, используя изображения, Live2D или VRM модели. В программе доступно 28 различных эмоций.",
        featureTitle5: "Интеграция с Hugging Face",
        featureDesc5: "Загружайте и управляйте локальными языковыми моделями прямо в приложении. Поддерживается удобный формат GGUF для быстрой и эффективной работы на вашем устройстве. Работает на процессорах и видеокартах NVIDIA и AMD.",
        featureTitle6: "Широкие возможности",
        featureDesc6: "Ощутите весь спектр эмоций от ролевых игр с любимыми персонажами, тонко настраивая каждый аспект взаимодействия: системные промпты, лорбуки, параметры моделей, персоны пользователя и многое другое.",
        screenshotsTitle: "Интерфейс приложения",
        screenshotTitle1: "Главное меню с персонажами",
        screenshotDesc1: "Удобное управление всеми вашими персонажами в одном месте",
        screenshotTitle2: "Врата Персонажей",
        screenshotDesc2: "Ищите и добавляйте нужных персонажей через специальный раздел",
        screenshotTitle3: "Многофункциональный чат",
        screenshotDesc3: "Общайтесь с любимыми персонажами в многофункциональном чате, где вы можете кастомизировать фон, аватар, авторские заметки, а также звонить персонажу",
        screenshotTitle4: "Продвинутые настройки",
        screenshotDesc4: "Экспериментируйте с гибкими настройками и адаптируйте программу под свои потребности",
        screenshotTitle5: "Локальные языковые модели",
        screenshotDesc5: "Загружайте и управляйте локальными языковыми моделями прямо в приложении, благодаря интеграции с сайтом Hugging Face",
        screenshotTitle6: "Soul of Waifu System",
        screenshotDesc6: "Разговаривайте с персонажем через микрофон с помощью модуля Soul of Waifu System",
        historyTitle: "История развития",
        historyTitle1: "Консольная программа",
        historyDesc1: "Начало пути - простая консольная утилита для взаимодействия с ИИ. Базовая функциональность и текстовый интерфейс.",
        historyTitle2: "Полноценный графический интерфейс",
        historyDesc2: "Переход от консоли к графическому интерфейсу. Работал только с Character AI и не имел большинства функций.",
        historyTitle3: "Полностью с нуля",
        historyDesc3: "Полная переработка архитектуры и переписанный с нуля код. Добавлена поддержка облачных сервисов и локальных языковых моделей, аватары персонажей и модуль Soul of Waifu System.",
        historyTitle4: "Крупнейшее обновление v2.2",
        historyDesc4: "Новейшая версия с полностью переработанным интерфейсом, поддержкой VRM моделей, множественных персон, лорбуков, изменения системных промптов, эмбиента, умной памяти, новых TTS-систем и многого другого.",
        downloadTitle: "Скачать Soul of Waifu",
        downloadDescription: "Загрузите самую последнюю версию приложения и погрузитесь в мир ролевых игр с искусственным интеллектом уже сейчас!",
        windowsBtn: "Скачать для Windows",
        versionText: "Версия 2.2.0 | Размер: ~7GB | ",
        changelogLink: "История изменений",
        footerTitle: "Soul of Waifu",
        footerDescription: "Уникальное приложение для взаимодействия с ИИ-персонажами. Создавайте, настраивайте и общайтесь без лишних трудностей.",
        navigationTitle: "Навигация",
        footerHome: "Главная",
        footerFeatures: "Возможности",
        footerScreenshots: "Скриншоты",
        footerHistory: "История",
        footerDownload: "Скачать",
        resourcesTitle: "Ресурсы",
        githubLink: "GitHub репозиторий",
        docsLink: "Документация",
        contactsTitle: "Социальные сети",
        youtubeLink: "YouTube канал",
        telegramLink: "Telegram канал",
        discordLink: "Discord сервер",
        copyrightText: "&copy; 2025 Soul of Waifu. Разработал jofizcd."
    },
    en: {
        features: "Features",
        screenshots: "Screenshots",
        history: "History",
        download: "Download",
        heroTitle: "Breathe soul into your beloved characters",
        heroDescription: "Soul of Waifu is an open-source desktop application where you can bring characters to life and interact with AI models — even run them locally. No complicated setup, just instant immersion into AI-powered roleplay.",
        downloadBtn: "Download for Windows",
        learnMoreBtn: "Documentation",
        scrollText: "Scroll down",
        featuresTitle: "Key Features",
        featureTitle1: "Simplicity and Ease",
        featureDesc1: "Even if you're new to AI, don't worry. An intuitive interface makes interacting with the app easy, clear, and enjoyable from the very first launch.",
        featureTitle2: "Language Models",
        featureDesc2: "Use APIs from leading platforms, or run local language models directly within the app.",
        featureTitle3: "Character Interaction",
        featureDesc3: "Chat with characters using a feature-rich chat interface — customize, manage messages, import chats, and even call your character.",
        featureTitle4: "Voice and Animation",
        featureDesc4: "Characters can speak through various TTS systems and react with poses and animations using images, Live2D, or VRM models. The app supports 28 different emotions.",
        featureTitle5: "Hugging Face Integration",
        featureDesc5: "Download and manage local language models directly in the app. Supports the efficient GGUF format for fast, effective performance on your device. Works with NVIDIA and AMD GPUs and CPUs.",
        featureTitle6: "Advanced Customization",
        featureDesc6: "Experience the full range of roleplay emotions by finely tuning every interaction aspect: system prompts, lorebooks, model parameters, user personas, and more.",
        screenshotsTitle: "Application Interface",
        screenshotTitle1: "Main Menu with Characters",
        screenshotDesc1: "Conveniently manage all your characters in one place",
        screenshotTitle2: "Character Gateway",
        screenshotDesc2: "Search and add characters through a dedicated section",
        screenshotTitle3: "Multifunctional Chat",
        screenshotDesc3: "Chat with your favorite characters in a rich chat interface where you can customize background, avatar, author's notes, and even call the character",
        screenshotTitle4: "Advanced Settings",
        screenshotDesc4: "Experiment with flexible settings and adapt the app to your needs",
        screenshotTitle5: "Local Language Models",
        screenshotDesc5: "Download and manage local language models directly in the app via Hugging Face integration",
        screenshotTitle6: "Soul of Waifu System",
        screenshotDesc6: "Talk to your character via microphone using the Soul of Waifu System module",
        historyTitle: "Development History",
        historyTitle1: "Console Program",
        historyDesc1: "The beginning — a simple console utility for AI interaction. Basic functionality and text-based interface.",
        historyTitle2: "Full GUI",
        historyDesc2: "Transition from console to graphical interface. Initially worked only with Character AI and lacked most features.",
        historyTitle3: "Complete Rewrite",
        historyDesc3: "Full architectural overhaul and code rewritten from scratch. Added support for cloud services and local models, character avatars, and the Soul of Waifu System module.",
        historyTitle4: "Major Update v2.2",
        historyDesc4: "The latest version features a completely redesigned interface, VRM model support, multiple characters, lorebooks, dynamic system prompts, ambiance, smart memory, new TTS systems, and much more.",
        downloadTitle: "Download Soul of Waifu",
        downloadDescription: "Get the latest version of the app and dive into the world of AI-powered roleplay today!",
        windowsBtn: "Download for Windows",
        versionText: "Version 2.2.0 | Size: ~7GB | ",
        changelogLink: "Changelog",
        footerTitle: "Soul of Waifu",
        footerDescription: "A unique application for interacting with AI characters. Create, customize, and communicate without unnecessary complexity.",
        navigationTitle: "Navigation",
        footerHome: "Home",
        footerFeatures: "Features",
        footerScreenshots: "Screenshots",
        footerHistory: "History",
        footerDownload: "Download",
        resourcesTitle: "Resources",
        githubLink: "GitHub Repository",
        docsLink: "Documentation",
        contactsTitle: "Social Network",
        youtubeLink: "YouTube Channel",
        telegramLink: "Telegram Channel",
        discordLink: "Discord Server",
        copyrightText: "&copy; 2025 Soul of Waifu. Created by jofizcd."
    }
};

function saveSettings(settings) {
    try {
        localStorage.setItem('soulofwaifu_settings', JSON.stringify(settings));
    } catch (e) {
        console.warn("Не удалось сохранить настройки в localStorage:", e);
    }
}

function loadSettings() {
    try {
        const settingsStr = localStorage.getItem('soulofwaifu_settings');
        if (settingsStr) {
            return JSON.parse(settingsStr);
        }
    } catch (e) {
        console.warn("Не удалось загрузить настройки из localStorage:", e);
    }
    return { theme: 'dark', language: 'ru' };
}

function applySettings(settings) {
    if (settings.theme === 'light') {
        document.body.classList.add('light-theme');

        const logoDark = document.querySelector('.logo-dark');
        const logoLight = document.querySelector('.logo-light');
        if (logoDark) logoDark.style.display = 'none';
        if (logoLight) logoLight.style.display = 'block';
    } else {
        document.body.classList.remove('light-theme');
        const logoDark = document.querySelector('.logo-dark');
        const logoLight = document.querySelector('.logo-light');
        if (logoDark) logoDark.style.display = 'block';
        if (logoLight) logoLight.style.display = 'none';
    }

    updateLanguage(settings.language);
    if (document.getElementById('languageSelector')) {
        document.getElementById('languageSelector').value = settings.language;
    }
}

document.addEventListener('DOMContentLoaded', function() {
    const themeToggle = document.getElementById('themeToggle');
    if (themeToggle) {
        themeToggle.addEventListener('click', function() {
            document.body.classList.toggle('light-theme');

            const logoDark = document.querySelector('.logo-dark');
            const logoLight = document.querySelector('.logo-light');
            if (document.body.classList.contains('light-theme')) {
                if (logoDark) logoDark.style.display = 'none';
                if (logoLight) logoLight.style.display = 'block';
            } else {
                if (logoDark) logoDark.style.display = 'block';
                if (logoLight) logoLight.style.display = 'none';
            }

            const currentLang = document.getElementById('languageSelector') ? document.getElementById('languageSelector').value : 'ru';
            const currentTheme = document.body.classList.contains('light-theme') ? 'light' : 'dark';
            saveSettings({ theme: currentTheme, language: currentLang });
        });
    }

    const languageSelector = document.getElementById('languageSelector');
    if (languageSelector) {
        languageSelector.addEventListener('change', function() {
            const selectedLang = this.value;
            updateLanguage(selectedLang);

            const currentTheme = document.body.classList.contains('light-theme') ? 'light' : 'dark';
            saveSettings({ theme: currentTheme, language: selectedLang });
        });
    }

    const savedSettings = loadSettings();
    applySettings(savedSettings);

    const navLinks = document.querySelectorAll('nav a');
    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            navLinks.forEach(l => l.classList.remove('active'));
            this.classList.add('active');
            const targetId = this.getAttribute('href');
            const targetElement = document.querySelector(targetId);
            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
    const fadeElements = document.querySelectorAll('.fade-in');
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('appear');
            }
        });
    }, {
        threshold: 0.1
    });
    fadeElements.forEach(element => {
        observer.observe(element);
    });
    const buttons = document.querySelectorAll('.btn');
    buttons.forEach(button => {
        button.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-3px)';
        });
        button.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0)';
        });
    });
    initParticles();
    initHistoryParticles();
    window.addEventListener('scroll', function() {
        const sections = document.querySelectorAll('section');
        const scrollPos = window.scrollY + 100;
        sections.forEach(section => {
            const top = section.offsetTop;
            const bottom = top + section.offsetHeight;
            const id = section.getAttribute('id');
            if (scrollPos >= top && scrollPos <= bottom) {
                navLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === `#${id}`) {
                        link.classList.add('active');
                    }
                });
            }
        });
    });
});

function updateLanguage(lang) {
    const t = translations[lang];
    document.querySelector('.nav-features').textContent = t.features;
    document.querySelector('.nav-screenshots').textContent = t.screenshots;
    document.querySelector('.nav-history').textContent = t.history;
    document.querySelector('.nav-download').textContent = t.download;
    document.querySelector('.hero-title').textContent = t.heroTitle;
    document.querySelector('.hero-description').innerHTML = t.heroDescription;
    document.querySelector('.download-btn').textContent = t.downloadBtn;
    document.querySelector('.docs-btn').textContent = t.learnMoreBtn;
    document.querySelector('.scroll-text').textContent = t.scrollText;
    document.querySelector('.features-title').textContent = t.featuresTitle;
    document.querySelector('.feature-title-1').textContent = t.featureTitle1;
    document.querySelector('.feature-desc-1').textContent = t.featureDesc1;
    document.querySelector('.feature-title-2').textContent = t.featureTitle2;
    document.querySelector('.feature-desc-2').textContent = t.featureDesc2;
    document.querySelector('.feature-title-3').textContent = t.featureTitle3;
    document.querySelector('.feature-desc-3').textContent = t.featureDesc3;
    document.querySelector('.feature-title-4').textContent = t.featureTitle4;
    document.querySelector('.feature-desc-4').textContent = t.featureDesc4;
    document.querySelector('.feature-title-5').textContent = t.featureTitle5;
    document.querySelector('.feature-desc-5').textContent = t.featureDesc5;
    document.querySelector('.feature-title-6').textContent = t.featureTitle6;
    document.querySelector('.feature-desc-6').textContent = t.featureDesc6;
    document.querySelector('.screenshots-title').textContent = t.screenshotsTitle;
    document.querySelector('.screenshot-title-1').textContent = t.screenshotTitle1;
    document.querySelector('.screenshot-desc-1').textContent = t.screenshotDesc1;
    document.querySelector('.screenshot-title-2').textContent = t.screenshotTitle2;
    document.querySelector('.screenshot-desc-2').textContent = t.screenshotDesc2;
    document.querySelector('.screenshot-title-3').textContent = t.screenshotTitle3;
    document.querySelector('.screenshot-desc-3').textContent = t.screenshotDesc3;
    document.querySelector('.screenshot-title-4').textContent = t.screenshotTitle4;
    document.querySelector('.screenshot-desc-4').textContent = t.screenshotDesc4;
    document.querySelector('.screenshot-title-5').textContent = t.screenshotTitle5;
    document.querySelector('.screenshot-desc-5').textContent = t.screenshotDesc5;
    document.querySelector('.screenshot-title-6').textContent = t.screenshotTitle6;
    document.querySelector('.screenshot-desc-6').textContent = t.screenshotDesc6;
    document.querySelector('.history-title').textContent = t.historyTitle;
    document.querySelector('.history-title-1').textContent = t.historyTitle1;
    document.querySelector('.history-desc-1').textContent = t.historyDesc1;
    document.querySelector('.history-title-2').textContent = t.historyTitle2;
    document.querySelector('.history-desc-2').textContent = t.historyDesc2;
    document.querySelector('.history-title-3').textContent = t.historyTitle3;
    document.querySelector('.history-desc-3').textContent = t.historyDesc3;
    document.querySelector('.history-title-4').textContent = t.historyTitle4;
    document.querySelector('.history-desc-4').textContent = t.historyDesc4;
    document.querySelector('.download-title').textContent = t.downloadTitle;
    document.querySelector('.download-description').textContent = t.downloadDescription;
    document.querySelector('.windows-btn').textContent = t.windowsBtn;
    document.querySelector('.version-text').textContent = t.versionText;
    document.querySelector('.changelog-link').textContent = t.changelogLink;
    document.querySelector('.footer-title').textContent = t.footerTitle;
    document.querySelector('.footer-description').textContent = t.footerDescription;
    document.querySelector('.navigation-title').textContent = t.navigationTitle;
    document.querySelector('.footer-home').textContent = t.footerHome;
    document.querySelector('.footer-features').textContent = t.footerFeatures;
    document.querySelector('.footer-screenshots').textContent = t.footerScreenshots;
    document.querySelector('.footer-history').textContent = t.footerHistory;
    document.querySelector('.footer-download').textContent = t.footerDownload;
    document.querySelector('.resources-title').textContent = t.resourcesTitle;
    document.querySelector('.github-link-2').textContent = t.githubLink;
    document.querySelector('.docs-link').textContent = t.docsLink;
    document.querySelector('.contacts-title').textContent = t.contactsTitle;
    document.querySelector('.youtube-link').textContent = t.youtubeLink;
    document.querySelector('.telegram-link-2').textContent = t.telegramLink;
    document.querySelector('.discord-link-2').textContent = t.discordLink;
    document.querySelector('.copyright-text').innerHTML = t.copyrightText;
}

function initParticles() {
    const canvas = document.createElement('canvas');
    const container = document.getElementById('particles-js');
    if (container) {
        container.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        window.addEventListener('resize', resize);
        resize();
        const particles = [];
        const particleCount = 80;
        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.5;
                this.vy = (Math.random() - 0.5) * 0.5;
                this.radius = Math.random() * 1.5 + 0.5;
                this.opacity = Math.random() * 0.5 + 0.1;
                this.color = Math.random() > 0.5 ? '#1e3a8a' : '#3b82f6';
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 100) {
                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(30, 58, 138, ${0.2 * (1 - distance/100)})`;
                        ctx.lineWidth = 0.5;
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
            requestAnimationFrame(animate);
        }
        animate();
    }
}

function initHistoryParticles() {
    const canvas = document.createElement('canvas');
    const container = document.getElementById('history-particles');
    if (container) {
        container.appendChild(canvas);
        const ctx = canvas.getContext('2d');
        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        window.addEventListener('resize', resize);
        resize();
        const particles = [];
        const particleCount = 100;
        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.3;
                this.vy = (Math.random() - 0.5) * 0.3;
                this.radius = Math.random() * 2 + 0.5;
                this.opacity = Math.random() * 0.4 + 0.1;
                this.color = Math.random() > 0.7 ? '#3b82f6' : 
                           Math.random() > 0.5 ? '#60a5fa' : '#93c5fd';
                this.pulseDirection = Math.random() > 0.5 ? 1 : -1;
                this.pulseSpeed = Math.random() * 0.02 + 0.005;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
                
                this.pulsePhase += this.pulseSpeed;
                this.currentRadius = this.radius + Math.sin(this.pulsePhase) * 0.5;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.opacity;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });

            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 80) {
                        ctx.beginPath();
                        ctx.strokeStyle = `rgba(59, 130, 246, ${0.1 * (1 - distance/80)})`;
                        ctx.lineWidth = 0.3;
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
            requestAnimationFrame(animate);
        }
        animate();
    }
}